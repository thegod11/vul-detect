[
    {
        "project":"FFmpeg",
        "commit_id":"973b1a6b9070e2bf17d17568cbaf4043ce931f51",
        "target":0,
        "func":"static av_cold int vdadec_init(AVCodecContext *avctx)\n\n{\n\n    VDADecoderContext *ctx = avctx->priv_data;\n\n    struct vda_context *vda_ctx = &ctx->vda_ctx;\n\n    OSStatus status;\n\n    int ret;\n\n\n\n    ctx->h264_initialized = 0;\n\n\n\n    \/* init pix_fmts of codec *\/\n\n    if (!ff_h264_vda_decoder.pix_fmts) {\n\n        if (kCFCoreFoundationVersionNumber < kCFCoreFoundationVersionNumber10_7)\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts_prior_10_7;\n\n        else\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts;\n\n    }\n\n\n\n    \/* init vda *\/\n\n    memset(vda_ctx, 0, sizeof(struct vda_context));\n\n    vda_ctx->width = avctx->width;\n\n    vda_ctx->height = avctx->height;\n\n    vda_ctx->format = 'avc1';\n\n    vda_ctx->use_sync_decoding = 1;\n\n    vda_ctx->use_ref_buffer = 1;\n\n    ctx->pix_fmt = avctx->get_format(avctx, avctx->codec->pix_fmts);\n\n    switch (ctx->pix_fmt) {\n\n    case AV_PIX_FMT_UYVY422:\n\n        vda_ctx->cv_pix_fmt_type = '2vuy';\n\n        break;\n\n    case AV_PIX_FMT_YUYV422:\n\n        vda_ctx->cv_pix_fmt_type = 'yuvs';\n\n        break;\n\n    case AV_PIX_FMT_NV12:\n\n        vda_ctx->cv_pix_fmt_type = '420v';\n\n        break;\n\n    case AV_PIX_FMT_YUV420P:\n\n        vda_ctx->cv_pix_fmt_type = 'y420';\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported pixel format: %d\\n\", avctx->pix_fmt);\n\n        goto failed;\n\n    }\n\n    status = ff_vda_create_decoder(vda_ctx,\n\n                                   avctx->extradata, avctx->extradata_size);\n\n    if (status != kVDADecoderNoErr) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n                \"Failed to init VDA decoder: %d.\\n\", status);\n\n        goto failed;\n\n    }\n\n    avctx->hwaccel_context = vda_ctx;\n\n\n\n    \/* changes callback functions *\/\n\n    avctx->get_format = get_format;\n\n    avctx->get_buffer2 = get_buffer2;\n\n#if FF_API_GET_BUFFER\n\n    \/\/ force the old get_buffer to be empty\n\n    avctx->get_buffer = NULL;\n\n#endif\n\n\n\n    \/* init H.264 decoder *\/\n\n    ret = ff_h264_decoder.init(avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 decoder.\\n\");\n\n        goto failed;\n\n    }\n\n    ctx->h264_initialized = 1;\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    vdadec_close(avctx);\n\n    return -1;\n\n}\n"
    },
    {
        "project":"FFmpeg",
        "commit_id":"321b2a9ded0468670b7678b7c098886930ae16b2",
        "target":0,
        "func":"static int transcode(AVFormatContext **output_files,\n\n                     int nb_output_files,\n\n                     InputFile *input_files,\n\n                     int nb_input_files,\n\n                     StreamMap *stream_maps, int nb_stream_maps)\n\n{\n\n    int ret = 0, i, j, k, n, nb_ostreams = 0, step;\n\n\n\n    AVFormatContext *is, *os;\n\n    AVCodecContext *codec, *icodec;\n\n    OutputStream *ost, **ost_table = NULL;\n\n    InputStream *ist;\n\n    char error[1024];\n\n    int key;\n\n    int want_sdp = 1;\n\n    uint8_t no_packet[MAX_FILES]={0};\n\n    int no_packet_count=0;\n\n    int nb_frame_threshold[AVMEDIA_TYPE_NB]={0};\n\n    int nb_streams[AVMEDIA_TYPE_NB]={0};\n\n\n\n    if (rate_emu)\n\n        for (i = 0; i < nb_input_streams; i++)\n\n            input_streams[i].start = av_gettime();\n\n\n\n    \/* output stream init *\/\n\n    nb_ostreams = 0;\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n\n            av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n            fprintf(stderr, \"Output file #%d does not contain any stream\\n\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        nb_ostreams += os->nb_streams;\n\n    }\n\n    if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n\n        fprintf(stderr, \"Number of stream maps must match number of output streams\\n\");\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    \/* Sanity check the mapping args -- do the input files & streams exist? *\/\n\n    for(i=0;i<nb_stream_maps;i++) {\n\n        int fi = stream_maps[i].file_index;\n\n        int si = stream_maps[i].stream_index;\n\n\n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find input stream #%d.%d\\n\", fi, si);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        fi = stream_maps[i].sync_file_index;\n\n        si = stream_maps[i].sync_stream_index;\n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find sync stream #%d.%d\\n\", fi, si);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ost_table = av_mallocz(sizeof(OutputStream *) * nb_ostreams);\n\n    if (!ost_table)\n\n        goto fail;\n\n\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++,n++) {\n\n            nb_streams[os->streams[i]->codec->codec_type]++;\n\n        }\n\n    }\n\n    for(step=1<<30; step; step>>=1){\n\n        int found_streams[AVMEDIA_TYPE_NB]={0};\n\n        for(j=0; j<AVMEDIA_TYPE_NB; j++)\n\n            nb_frame_threshold[j] += step;\n\n\n\n        for(j=0; j<nb_input_streams; j++) {\n\n            int skip=0;\n\n            ist = &input_streams[j];\n\n            if(opt_programid){\n\n                int pi,si;\n\n                AVFormatContext *f= input_files[ ist->file_index ].ctx;\n\n                skip=1;\n\n                for(pi=0; pi<f->nb_programs; pi++){\n\n                    AVProgram *p= f->programs[pi];\n\n                    if(p->id == opt_programid)\n\n                        for(si=0; si<p->nb_stream_indexes; si++){\n\n                            if(f->streams[ p->stream_index[si] ] == ist->st)\n\n                                skip=0;\n\n                        }\n\n                }\n\n            }\n\n            if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip\n\n                && nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames){\n\n                found_streams[ist->st->codec->codec_type]++;\n\n            }\n\n        }\n\n        for(j=0; j<AVMEDIA_TYPE_NB; j++)\n\n            if(found_streams[j] < nb_streams[j])\n\n                nb_frame_threshold[j] -= step;\n\n    }\n\n    n = 0;\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++,n++) {\n\n            int found;\n\n            ost = ost_table[n] = output_streams_for_file[k][i];\n\n            if (nb_stream_maps > 0) {\n\n                ost->source_index = input_files[stream_maps[n].file_index].ist_index +\n\n                    stream_maps[n].stream_index;\n\n\n\n                \/* Sanity check that the stream types match *\/\n\n                if (input_streams[ost->source_index].st->codec->codec_type != ost->st->codec->codec_type) {\n\n                    int i= ost->file_index;\n\n                    av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n                    fprintf(stderr, \"Codec type mismatch for mapping #%d.%d -> #%d.%d\\n\",\n\n                        stream_maps[n].file_index, stream_maps[n].stream_index,\n\n                        ost->file_index, ost->index);\n\n                    ffmpeg_exit(1);\n\n                }\n\n\n\n            } else {\n\n                \/* get corresponding input stream index : we select the first one with the right type *\/\n\n                found = 0;\n\n                for (j = 0; j < nb_input_streams; j++) {\n\n                    int skip=0;\n\n                    ist = &input_streams[j];\n\n                    if(opt_programid){\n\n                        int pi,si;\n\n                        AVFormatContext *f = input_files[ist->file_index].ctx;\n\n                        skip=1;\n\n                        for(pi=0; pi<f->nb_programs; pi++){\n\n                            AVProgram *p= f->programs[pi];\n\n                            if(p->id == opt_programid)\n\n                                for(si=0; si<p->nb_stream_indexes; si++){\n\n                                    if(f->streams[ p->stream_index[si] ] == ist->st)\n\n                                        skip=0;\n\n                                }\n\n                        }\n\n                    }\n\n                    if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip &&\n\n                        ist->st->codec->codec_type == ost->st->codec->codec_type &&\n\n                        nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames) {\n\n                            ost->source_index = j;\n\n                            found = 1;\n\n                            break;\n\n                    }\n\n                }\n\n\n\n                if (!found) {\n\n                    if(! opt_programid) {\n\n                        \/* try again and reuse existing stream *\/\n\n                        for (j = 0; j < nb_input_streams; j++) {\n\n                            ist = &input_streams[j];\n\n                            if (   ist->st->codec->codec_type == ost->st->codec->codec_type\n\n                                && ist->st->discard != AVDISCARD_ALL) {\n\n                                ost->source_index = j;\n\n                                found = 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    if (!found) {\n\n                        int i= ost->file_index;\n\n                        av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n                        fprintf(stderr, \"Could not find input stream matching output stream #%d.%d\\n\",\n\n                                ost->file_index, ost->index);\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                }\n\n            }\n\n            ist = &input_streams[ost->source_index];\n\n            ist->discard = 0;\n\n            ost->sync_ist = (nb_stream_maps > 0) ?\n\n                &input_streams[input_files[stream_maps[n].sync_file_index].ist_index +\n\n                         stream_maps[n].sync_stream_index] : ist;\n\n        }\n\n    }\n\n\n\n    \/* for each output stream, we compute the right encoding parameters *\/\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        os = output_files[ost->file_index];\n\n        ist = &input_streams[ost->source_index];\n\n\n\n        codec = ost->st->codec;\n\n        icodec = ist->st->codec;\n\n\n\n        if (metadata_streams_autocopy)\n\n            av_dict_copy(&ost->st->metadata, ist->st->metadata,\n\n                         AV_DICT_DONT_OVERWRITE);\n\n\n\n        ost->st->disposition = ist->st->disposition;\n\n        codec->bits_per_raw_sample= icodec->bits_per_raw_sample;\n\n        codec->chroma_sample_location = icodec->chroma_sample_location;\n\n\n\n        if (ost->st->stream_copy) {\n\n            uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n\n\n\n            if (extra_size > INT_MAX)\n\n                goto fail;\n\n\n\n            \/* if stream_copy is selected, no need to decode or encode *\/\n\n            codec->codec_id = icodec->codec_id;\n\n            codec->codec_type = icodec->codec_type;\n\n\n\n            if(!codec->codec_tag){\n\n                if(   !os->oformat->codec_tag\n\n                   || av_codec_get_id (os->oformat->codec_tag, icodec->codec_tag) == codec->codec_id\n\n                   || av_codec_get_tag(os->oformat->codec_tag, icodec->codec_id) <= 0)\n\n                    codec->codec_tag = icodec->codec_tag;\n\n            }\n\n\n\n            codec->bit_rate = icodec->bit_rate;\n\n            codec->rc_max_rate    = icodec->rc_max_rate;\n\n            codec->rc_buffer_size = icodec->rc_buffer_size;\n\n            codec->extradata= av_mallocz(extra_size);\n\n            if (!codec->extradata)\n\n                goto fail;\n\n            memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n\n            codec->extradata_size= icodec->extradata_size;\n\n            if(!copy_tb && av_q2d(icodec->time_base)*icodec->ticks_per_frame > av_q2d(ist->st->time_base) && av_q2d(ist->st->time_base) < 1.0\/500){\n\n                codec->time_base = icodec->time_base;\n\n                codec->time_base.num *= icodec->ticks_per_frame;\n\n                av_reduce(&codec->time_base.num, &codec->time_base.den,\n\n                          codec->time_base.num, codec->time_base.den, INT_MAX);\n\n            }else\n\n                codec->time_base = ist->st->time_base;\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                if(audio_volume != 256) {\n\n                    fprintf(stderr,\"-acodec copy and -vol are incompatible (frames are not decoded)\\n\");\n\n                    ffmpeg_exit(1);\n\n                }\n\n                codec->channel_layout = icodec->channel_layout;\n\n                codec->sample_rate = icodec->sample_rate;\n\n                codec->channels = icodec->channels;\n\n                codec->frame_size = icodec->frame_size;\n\n                codec->audio_service_type = icodec->audio_service_type;\n\n                codec->block_align= icodec->block_align;\n\n                if(codec->block_align == 1 && codec->codec_id == CODEC_ID_MP3)\n\n                    codec->block_align= 0;\n\n                if(codec->codec_id == CODEC_ID_AC3)\n\n                    codec->block_align= 0;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                codec->pix_fmt = icodec->pix_fmt;\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                codec->has_b_frames = icodec->has_b_frames;\n\n                if (!codec->sample_aspect_ratio.num) {\n\n                    codec->sample_aspect_ratio =\n\n                    ost->st->sample_aspect_ratio =\n\n                        ist->st->sample_aspect_ratio.num ? ist->st->sample_aspect_ratio :\n\n                        ist->st->codec->sample_aspect_ratio.num ?\n\n                        ist->st->codec->sample_aspect_ratio : (AVRational){0, 1};\n\n                }\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                break;\n\n            case AVMEDIA_TYPE_DATA:\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n        } else {\n\n            if (!ost->enc)\n\n                ost->enc = avcodec_find_encoder(ost->st->codec->codec_id);\n\n            switch(codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                ost->fifo= av_fifo_alloc(1024);\n\n                if(!ost->fifo)\n\n                    goto fail;\n\n                ost->reformat_pair = MAKE_SFMT_PAIR(AV_SAMPLE_FMT_NONE,AV_SAMPLE_FMT_NONE);\n\n                if (!codec->sample_rate) {\n\n                    codec->sample_rate = icodec->sample_rate;\n\n                    if (icodec->lowres)\n\n                        codec->sample_rate >>= icodec->lowres;\n\n                }\n\n                choose_sample_rate(ost->st, ost->enc);\n\n                codec->time_base = (AVRational){1, codec->sample_rate};\n\n                if (codec->sample_fmt == AV_SAMPLE_FMT_NONE)\n\n                    codec->sample_fmt = icodec->sample_fmt;\n\n                choose_sample_fmt(ost->st, ost->enc);\n\n                if (!codec->channels) {\n\n                    codec->channels = icodec->channels;\n\n                    codec->channel_layout = icodec->channel_layout;\n\n                }\n\n                if (av_get_channel_layout_nb_channels(codec->channel_layout) != codec->channels)\n\n                    codec->channel_layout = 0;\n\n                ost->audio_resample = codec->sample_rate != icodec->sample_rate || audio_sync_method > 1;\n\n                icodec->request_channels = codec->channels;\n\n                ist->decoding_needed = 1;\n\n                ost->encoding_needed = 1;\n\n                ost->resample_sample_fmt  = icodec->sample_fmt;\n\n                ost->resample_sample_rate = icodec->sample_rate;\n\n                ost->resample_channels    = icodec->channels;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                if (codec->pix_fmt == PIX_FMT_NONE)\n\n                    codec->pix_fmt = icodec->pix_fmt;\n\n                choose_pixel_fmt(ost->st, ost->enc);\n\n\n\n                if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n\n                    fprintf(stderr, \"Video pixel format is unknown, stream cannot be encoded\\n\");\n\n                    ffmpeg_exit(1);\n\n                }\n\n                ost->video_resample = codec->width   != icodec->width  ||\n\n                                      codec->height  != icodec->height ||\n\n                                      codec->pix_fmt != icodec->pix_fmt;\n\n                if (ost->video_resample) {\n\n                    codec->bits_per_raw_sample= frame_bits_per_raw_sample;\n\n                }\n\n                if (!codec->width || !codec->height) {\n\n                    codec->width  = icodec->width;\n\n                    codec->height = icodec->height;\n\n                }\n\n                ost->resample_height = icodec->height;\n\n                ost->resample_width  = icodec->width;\n\n                ost->resample_pix_fmt= icodec->pix_fmt;\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n\n\n                if (!ost->frame_rate.num)\n\n                    ost->frame_rate = ist->st->r_frame_rate.num ? ist->st->r_frame_rate : (AVRational){25,1};\n\n                if (ost->enc && ost->enc->supported_framerates && !force_fps) {\n\n                    int idx = av_find_nearest_q_idx(ost->frame_rate, ost->enc->supported_framerates);\n\n                    ost->frame_rate = ost->enc->supported_framerates[idx];\n\n                }\n\n                codec->time_base = (AVRational){ost->frame_rate.den, ost->frame_rate.num};\n\n                if(   av_q2d(codec->time_base) < 0.001 && video_sync_method\n\n                   && (video_sync_method==1 || (video_sync_method<0 && !(os->oformat->flags & AVFMT_VARIABLE_FPS)))){\n\n                    av_log(os, AV_LOG_WARNING, \"Frame rate very high for a muxer not effciciently supporting it.\\n\"\n\n                                               \"Please consider specifiying a lower framerate, a different muxer or -vsync 2\\n\");\n\n                }\n\n\n\n#if CONFIG_AVFILTER\n\n                if (configure_video_filters(ist, ost)) {\n\n                    fprintf(stderr, \"Error opening filters!\\n\");\n\n                    exit(1);\n\n                }\n\n#endif\n\n                break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n                break;\n\n            default:\n\n                abort();\n\n                break;\n\n            }\n\n            \/* two pass mode *\/\n\n            if (ost->encoding_needed && codec->codec_id != CODEC_ID_H264 &&\n\n                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {\n\n                char logfilename[1024];\n\n                FILE *f;\n\n\n\n                snprintf(logfilename, sizeof(logfilename), \"%s-%d.log\",\n\n                         pass_logfilename_prefix ? pass_logfilename_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX,\n\n                         i);\n\n                if (codec->flags & CODEC_FLAG_PASS1) {\n\n                    f = fopen(logfilename, \"wb\");\n\n                    if (!f) {\n\n                        fprintf(stderr, \"Cannot write log file '%s' for pass-1 encoding: %s\\n\", logfilename, strerror(errno));\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                    ost->logfile = f;\n\n                } else {\n\n                    char  *logbuffer;\n\n                    size_t logbuffer_size;\n\n                    if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n\n                        fprintf(stderr, \"Error reading log file '%s' for pass-2 encoding\\n\", logfilename);\n\n                        ffmpeg_exit(1);\n\n                    }\n\n                    codec->stats_in = logbuffer;\n\n                }\n\n            }\n\n        }\n\n        if(codec->codec_type == AVMEDIA_TYPE_VIDEO){\n\n            \/* maximum video buffer size is 6-bytes per pixel, plus DPX header size *\/\n\n            int size= codec->width * codec->height;\n\n            bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 1664);\n\n        }\n\n    }\n\n\n\n    if (!bit_buffer)\n\n        bit_buffer = av_malloc(bit_buffer_size);\n\n    if (!bit_buffer) {\n\n        fprintf(stderr, \"Cannot allocate %d bytes output buffer\\n\",\n\n                bit_buffer_size);\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    \/* open each encoder *\/\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            AVCodec *codec = ost->enc;\n\n            AVCodecContext *dec = input_streams[ost->source_index].st->codec;\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Encoder (codec id %d) not found for output stream #%d.%d\",\n\n                         ost->st->codec->codec_id, ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (dec->subtitle_header) {\n\n                ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n\n                if (!ost->st->codec->subtitle_header) {\n\n                    ret = AVERROR(ENOMEM);\n\n                    goto dump_format;\n\n                }\n\n                memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n\n                ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n\n            }\n\n            if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\",\n\n                        ost->file_index, ost->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ost->st->codec, 1);\n\n            assert_avoptions(ost->opts);\n\n            if (ost->st->codec->bit_rate && ost->st->codec->bit_rate < 1000)\n\n                av_log(NULL, AV_LOG_WARNING, \"The bitrate parameter is set too low.\"\n\n                                             \"It takes bits\/s as argument, not kbits\/s\\n\");\n\n            extra_size += ost->st->codec->extradata_size;\n\n        }\n\n    }\n\n\n\n    \/* open each decoder *\/\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            AVCodec *codec = ist->dec;\n\n            if (!codec)\n\n                codec = avcodec_find_decoder(ist->st->codec->codec_id);\n\n            if (!codec) {\n\n                snprintf(error, sizeof(error), \"Decoder (codec id %d) not found for input stream #%d.%d\",\n\n                        ist->st->codec->codec_id, ist->file_index, ist->st->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            if (avcodec_open2(ist->st->codec, codec, &ist->opts) < 0) {\n\n                snprintf(error, sizeof(error), \"Error while opening decoder for input stream #%d.%d\",\n\n                        ist->file_index, ist->st->index);\n\n                ret = AVERROR(EINVAL);\n\n                goto dump_format;\n\n            }\n\n            assert_codec_experimental(ist->st->codec, 0);\n\n            assert_avoptions(ost->opts);\n\n            \/\/if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            \/\/    ist->st->codec->flags |= CODEC_FLAG_REPEAT_FIELD;\n\n        }\n\n    }\n\n\n\n    \/* init pts *\/\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        AVStream *st;\n\n        ist = &input_streams[i];\n\n        st= ist->st;\n\n        ist->pts = st->avg_frame_rate.num ? - st->codec->has_b_frames*AV_TIME_BASE \/ av_q2d(st->avg_frame_rate) : 0;\n\n        ist->next_pts = AV_NOPTS_VALUE;\n\n        ist->is_start = 1;\n\n    }\n\n\n\n    \/* set meta data information from input file if required *\/\n\n    for (i=0;i<nb_meta_data_maps;i++) {\n\n        AVFormatContext *files[2];\n\n        AVDictionary    **meta[2];\n\n        int j;\n\n\n\n#define METADATA_CHECK_INDEX(index, nb_elems, desc)\\\n\n        if ((index) < 0 || (index) >= (nb_elems)) {\\\n\n            snprintf(error, sizeof(error), \"Invalid %s index %d while processing metadata maps\\n\",\\\n\n                     (desc), (index));\\\n\n            ret = AVERROR(EINVAL);\\\n\n            goto dump_format;\\\n\n        }\n\n\n\n        int out_file_index = meta_data_maps[i][0].file;\n\n        int in_file_index = meta_data_maps[i][1].file;\n\n        if (in_file_index < 0 || out_file_index < 0)\n\n            continue;\n\n        METADATA_CHECK_INDEX(out_file_index, nb_output_files, \"output file\")\n\n        METADATA_CHECK_INDEX(in_file_index, nb_input_files, \"input file\")\n\n\n\n        files[0] = output_files[out_file_index];\n\n        files[1] = input_files[in_file_index].ctx;\n\n\n\n        for (j = 0; j < 2; j++) {\n\n            MetadataMap *map = &meta_data_maps[i][j];\n\n\n\n            switch (map->type) {\n\n            case 'g':\n\n                meta[j] = &files[j]->metadata;\n\n                break;\n\n            case 's':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, \"stream\")\n\n                meta[j] = &files[j]->streams[map->index]->metadata;\n\n                break;\n\n            case 'c':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, \"chapter\")\n\n                meta[j] = &files[j]->chapters[map->index]->metadata;\n\n                break;\n\n            case 'p':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, \"program\")\n\n                meta[j] = &files[j]->programs[map->index]->metadata;\n\n                break;\n\n            }\n\n        }\n\n\n\n        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    \/* copy global metadata by default *\/\n\n    if (metadata_global_autocopy) {\n\n\n\n        for (i = 0; i < nb_output_files; i++)\n\n            av_dict_copy(&output_files[i]->metadata, input_files[0].ctx->metadata,\n\n                         AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    \/* copy chapters according to chapter maps *\/\n\n    for (i = 0; i < nb_chapter_maps; i++) {\n\n        int infile  = chapter_maps[i].in_file;\n\n        int outfile = chapter_maps[i].out_file;\n\n\n\n        if (infile < 0 || outfile < 0)\n\n            continue;\n\n        if (infile >= nb_input_files) {\n\n            snprintf(error, sizeof(error), \"Invalid input file index %d in chapter mapping.\\n\", infile);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        if (outfile >= nb_output_files) {\n\n            snprintf(error, sizeof(error), \"Invalid output file index %d in chapter mapping.\\n\",outfile);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        copy_chapters(infile, outfile);\n\n    }\n\n\n\n    \/* copy chapters from the first input file that has them*\/\n\n    if (!nb_chapter_maps)\n\n        for (i = 0; i < nb_input_files; i++) {\n\n            if (!input_files[i].ctx->nb_chapters)\n\n                continue;\n\n\n\n            for (j = 0; j < nb_output_files; j++)\n\n                if ((ret = copy_chapters(i, j)) < 0)\n\n                    goto dump_format;\n\n            break;\n\n        }\n\n\n\n    \/* open files and write file headers *\/\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (avformat_write_header(os, &output_opts[i]) < 0) {\n\n            snprintf(error, sizeof(error), \"Could not write header for output file #%d (incorrect codec parameters ?)\", i);\n\n            ret = AVERROR(EINVAL);\n\n            goto dump_format;\n\n        }\n\n        assert_avoptions(output_opts[i]);\n\n        if (strcmp(output_files[i]->oformat->name, \"rtp\")) {\n\n            want_sdp = 0;\n\n        }\n\n    }\n\n\n\n dump_format:\n\n    \/* dump the file output parameters - cannot be done before in case\n\n       of stream copy *\/\n\n    for(i=0;i<nb_output_files;i++) {\n\n        av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n    }\n\n\n\n    \/* dump the stream mapping *\/\n\n    if (verbose >= 0) {\n\n        fprintf(stderr, \"Stream mapping:\\n\");\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            fprintf(stderr, \"  Stream #%d.%d -> #%d.%d\",\n\n                    input_streams[ost->source_index].file_index,\n\n                    input_streams[ost->source_index].st->index,\n\n                    ost->file_index,\n\n                    ost->index);\n\n            if (ost->sync_ist != &input_streams[ost->source_index])\n\n                fprintf(stderr, \" [sync #%d.%d]\",\n\n                        ost->sync_ist->file_index,\n\n                        ost->sync_ist->st->index);\n\n            fprintf(stderr, \"\\n\");\n\n        }\n\n    }\n\n\n\n    if (ret) {\n\n        fprintf(stderr, \"%s\\n\", error);\n\n        goto fail;\n\n    }\n\n\n\n    if (want_sdp) {\n\n        print_sdp(output_files, nb_output_files);\n\n    }\n\n\n\n    if (!using_stdin) {\n\n        if(verbose >= 0)\n\n            fprintf(stderr, \"Press [q] to stop, [?] for help\\n\");\n\n        avio_set_interrupt_cb(decode_interrupt_cb);\n\n    }\n\n    term_init();\n\n\n\n    timer_start = av_gettime();\n\n\n\n    for(; received_sigterm == 0;) {\n\n        int file_index, ist_index;\n\n        AVPacket pkt;\n\n        double ipts_min;\n\n        double opts_min;\n\n\n\n    redo:\n\n        ipts_min= 1e100;\n\n        opts_min= 1e100;\n\n        \/* if 'q' pressed, exits *\/\n\n        if (!using_stdin) {\n\n            if (q_pressed)\n\n                break;\n\n            \/* read_key() returns 0 on EOF *\/\n\n            key = read_key();\n\n            if (key == 'q')\n\n                break;\n\n            if (key == '+') verbose++;\n\n            if (key == '-') verbose--;\n\n            if (key == 's') qp_hist     ^= 1;\n\n            if (key == 'h'){\n\n                if (do_hex_dump){\n\n                    do_hex_dump = do_pkt_dump = 0;\n\n                } else if(do_pkt_dump){\n\n                    do_hex_dump = 1;\n\n                } else\n\n                    do_pkt_dump = 1;\n\n                av_log_set_level(AV_LOG_DEBUG);\n\n            }\n\n            if (key == 'd' || key == 'D'){\n\n                int debug=0;\n\n                if(key == 'D') {\n\n                    debug = input_streams[0].st->codec->debug<<1;\n\n                    if(!debug) debug = 1;\n\n                    while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) \/\/unsupported, would just crash\n\n                        debug += debug;\n\n                }else\n\n                    scanf(\"%d\", &debug);\n\n                for(i=0;i<nb_input_streams;i++) {\n\n                    input_streams[i].st->codec->debug = debug;\n\n                }\n\n                for(i=0;i<nb_ostreams;i++) {\n\n                    ost = ost_table[i];\n\n                    ost->st->codec->debug = debug;\n\n                }\n\n                if(debug) av_log_set_level(AV_LOG_DEBUG);\n\n                fprintf(stderr,\"debug=%d\\n\", debug);\n\n            }\n\n            if (key == '?'){\n\n                fprintf(stderr, \"key    function\\n\"\n\n                                \"?      show this help\\n\"\n\n                                \"+      increase verbosity\\n\"\n\n                                \"-      decrease verbosity\\n\"\n\n                                \"D      cycle through available debug modes\\n\"\n\n                                \"h      dump packets\/hex press to cycle through the 3 states\\n\"\n\n                                \"q      quit\\n\"\n\n                                \"s      Show QP histogram\\n\"\n\n                );\n\n            }\n\n        }\n\n\n\n        \/* select the stream that we must read now by looking at the\n\n           smallest output pts *\/\n\n        file_index = -1;\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            double ipts, opts;\n\n            ost = ost_table[i];\n\n            os = output_files[ost->file_index];\n\n            ist = &input_streams[ost->source_index];\n\n            if(ist->is_past_recording_time || no_packet[ist->file_index])\n\n                continue;\n\n                opts = ost->st->pts.val * av_q2d(ost->st->time_base);\n\n            ipts = (double)ist->pts;\n\n            if (!input_files[ist->file_index].eof_reached){\n\n                if(ipts < ipts_min) {\n\n                    ipts_min = ipts;\n\n                    if(input_sync ) file_index = ist->file_index;\n\n                }\n\n                if(opts < opts_min) {\n\n                    opts_min = opts;\n\n                    if(!input_sync) file_index = ist->file_index;\n\n                }\n\n            }\n\n            if(ost->frame_number >= max_frames[ost->st->codec->codec_type]){\n\n                file_index= -1;\n\n                break;\n\n            }\n\n        }\n\n        \/* if none, if is finished *\/\n\n        if (file_index < 0) {\n\n            if(no_packet_count){\n\n                no_packet_count=0;\n\n                memset(no_packet, 0, sizeof(no_packet));\n\n                usleep(10000);\n\n                continue;\n\n            }\n\n            break;\n\n        }\n\n\n\n        \/* finish if limit size exhausted *\/\n\n        if (limit_filesize != 0 && limit_filesize <= avio_tell(output_files[0]->pb))\n\n            break;\n\n\n\n        \/* read a frame from it and output it in the fifo *\/\n\n        is = input_files[file_index].ctx;\n\n        ret= av_read_frame(is, &pkt);\n\n        if(ret == AVERROR(EAGAIN)){\n\n            no_packet[file_index]=1;\n\n            no_packet_count++;\n\n            continue;\n\n        }\n\n        if (ret < 0) {\n\n            input_files[file_index].eof_reached = 1;\n\n            if (opt_shortest)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        no_packet_count=0;\n\n        memset(no_packet, 0, sizeof(no_packet));\n\n\n\n        if (do_pkt_dump) {\n\n            av_pkt_dump_log2(NULL, AV_LOG_DEBUG, &pkt, do_hex_dump,\n\n                             is->streams[pkt.stream_index]);\n\n        }\n\n        \/* the following test is needed in case new streams appear\n\n           dynamically in stream : we ignore them *\/\n\n        if (pkt.stream_index >= input_files[file_index].ctx->nb_streams)\n\n            goto discard_packet;\n\n        ist_index = input_files[file_index].ist_index + pkt.stream_index;\n\n        ist = &input_streams[ist_index];\n\n        if (ist->discard)\n\n            goto discard_packet;\n\n\n\n        if (pkt.dts != AV_NOPTS_VALUE)\n\n            pkt.dts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n        if (pkt.pts != AV_NOPTS_VALUE)\n\n            pkt.pts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);\n\n\n\n        if (ist->ts_scale) {\n\n            if(pkt.pts != AV_NOPTS_VALUE)\n\n                pkt.pts *= ist->ts_scale;\n\n            if(pkt.dts != AV_NOPTS_VALUE)\n\n                pkt.dts *= ist->ts_scale;\n\n        }\n\n\n\n\/\/        fprintf(stderr, \"next:%\"PRId64\" dts:%\"PRId64\" off:%\"PRId64\" %d\\n\", ist->next_pts, pkt.dts, input_files[ist->file_index].ts_offset, ist->st->codec->codec_type);\n\n        if (pkt.dts != AV_NOPTS_VALUE && ist->next_pts != AV_NOPTS_VALUE\n\n            && (is->iformat->flags & AVFMT_TS_DISCONT)) {\n\n            int64_t pkt_dts= av_rescale_q(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n            int64_t delta= pkt_dts - ist->next_pts;\n\n            if((FFABS(delta) > 1LL*dts_delta_threshold*AV_TIME_BASE || pkt_dts+1<ist->pts)&& !copy_ts){\n\n                input_files[ist->file_index].ts_offset -= delta;\n\n                if (verbose > 2)\n\n                    fprintf(stderr, \"timestamp discontinuity %\"PRId64\", new offset= %\"PRId64\"\\n\",\n\n                            delta, input_files[ist->file_index].ts_offset);\n\n                pkt.dts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n\n                if(pkt.pts != AV_NOPTS_VALUE)\n\n                    pkt.pts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);\n\n            }\n\n        }\n\n\n\n        \/* finish if recording time exhausted *\/\n\n        if (recording_time != INT64_MAX &&\n\n            (pkt.pts != AV_NOPTS_VALUE ?\n\n                av_compare_ts(pkt.pts, ist->st->time_base, recording_time + start_time, (AVRational){1, 1000000})\n\n                    :\n\n                av_compare_ts(ist->pts, AV_TIME_BASE_Q, recording_time + start_time, (AVRational){1, 1000000})\n\n            )>= 0) {\n\n            ist->is_past_recording_time = 1;\n\n            goto discard_packet;\n\n        }\n\n\n\n        \/\/fprintf(stderr,\"read #%d.%d size=%d\\n\", ist->file_index, ist->st->index, pkt.size);\n\n        if (output_packet(ist, ist_index, ost_table, nb_ostreams, &pkt) < 0) {\n\n\n\n            if (verbose >= 0)\n\n                fprintf(stderr, \"Error while decoding stream #%d.%d\\n\",\n\n                        ist->file_index, ist->st->index);\n\n            if (exit_on_error)\n\n                ffmpeg_exit(1);\n\n            av_free_packet(&pkt);\n\n            goto redo;\n\n        }\n\n\n\n    discard_packet:\n\n        av_free_packet(&pkt);\n\n\n\n        \/* dump report by using the output first video and audio streams *\/\n\n        print_report(output_files, ost_table, nb_ostreams, 0);\n\n    }\n\n\n\n    \/* at the end of stream, we must flush the decoder buffers *\/\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            output_packet(ist, i, ost_table, nb_ostreams, NULL);\n\n        }\n\n    }\n\n\n\n    term_exit();\n\n\n\n    \/* write the trailer if needed and close file *\/\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        av_write_trailer(os);\n\n    }\n\n\n\n    \/* dump report by using the first video and audio streams *\/\n\n    print_report(output_files, ost_table, nb_ostreams, 1);\n\n\n\n    \/* close each encoder *\/\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            av_freep(&ost->st->codec->stats_in);\n\n            avcodec_close(ost->st->codec);\n\n        }\n\n#if CONFIG_AVFILTER\n\n        avfilter_graph_free(&ost->graph);\n\n#endif\n\n    }\n\n\n\n    \/* close each decoder *\/\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        ist = &input_streams[i];\n\n        if (ist->decoding_needed) {\n\n            avcodec_close(ist->st->codec);\n\n        }\n\n    }\n\n\n\n    \/* finished ! *\/\n\n    ret = 0;\n\n\n\n fail:\n\n    av_freep(&bit_buffer);\n\n\n\n    if (ost_table) {\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            if (ost) {\n\n                if (ost->st->stream_copy)\n\n                    av_freep(&ost->st->codec->extradata);\n\n                if (ost->logfile) {\n\n                    fclose(ost->logfile);\n\n                    ost->logfile = NULL;\n\n                }\n\n                av_fifo_free(ost->fifo); \/* works even if fifo is not\n\n                                             initialized but set to zero *\/\n\n                av_freep(&ost->st->codec->subtitle_header);\n\n                av_free(ost->resample_frame.data[0]);\n\n                av_free(ost->forced_kf_pts);\n\n                if (ost->video_resample)\n\n                    sws_freeContext(ost->img_resample_ctx);\n\n                if (ost->resample)\n\n                    audio_resample_close(ost->resample);\n\n                if (ost->reformat_ctx)\n\n                    av_audio_convert_free(ost->reformat_ctx);\n\n                av_dict_free(&ost->opts);\n\n                av_free(ost);\n\n            }\n\n        }\n\n        av_free(ost_table);\n\n    }\n\n    return ret;\n\n}\n"
    },
    {
        "project":"FFmpeg",
        "commit_id":"5d5de3eba4c7890c2e8077f5b4ae569671d11cf8",
        "target":0,
        "func":"static void v4l2_free_buffer(void *opaque, uint8_t *unused)\n\n{\n\n    V4L2Buffer* avbuf = opaque;\n\n    V4L2m2mContext *s = buf_to_m2mctx(avbuf);\n\n\n\n    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {\n\n        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);\n\n\n\n        if (s->reinit) {\n\n            if (!atomic_load(&s->refcount))\n\n                sem_post(&s->refsync);\n\n        } else if (avbuf->context->streamon)\n\n            ff_v4l2_buffer_enqueue(avbuf);\n\n\n\n        av_buffer_unref(&avbuf->context_ref);\n\n    }\n\n}\n"
    },
    {
        "project":"FFmpeg",
        "commit_id":"32bf6550cb9cc9f487a6722fe2bfc272a93c1065",
        "target":0,
        "func":"int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,\n\n                      AVCodecContext *codec, int size, int big_endian)\n\n{\n\n    int id;\n\n    uint64_t bitrate;\n\n\n\n    if (size < 14) {\n\n        avpriv_request_sample(codec, \"wav header size < 14\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    codec->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    if (!big_endian) {\n\n        id                 = avio_rl16(pb);\n\n        if (id != 0x0165) {\n\n            codec->channels    = avio_rl16(pb);\n\n            codec->sample_rate = avio_rl32(pb);\n\n            bitrate            = avio_rl32(pb) * 8LL;\n\n            codec->block_align = avio_rl16(pb);\n\n        }\n\n    } else {\n\n        id                 = avio_rb16(pb);\n\n        codec->channels    = avio_rb16(pb);\n\n        codec->sample_rate = avio_rb32(pb);\n\n        bitrate            = avio_rb32(pb) * 8LL;\n\n        codec->block_align = avio_rb16(pb);\n\n    }\n\n    if (size == 14) {  \/* We're dealing with plain vanilla WAVEFORMAT *\/\n\n        codec->bits_per_coded_sample = 8;\n\n    } else {\n\n        if (!big_endian) {\n\n            codec->bits_per_coded_sample = avio_rl16(pb);\n\n        } else {\n\n            codec->bits_per_coded_sample = avio_rb16(pb);\n\n        }\n\n    }\n\n    if (id == 0xFFFE) {\n\n        codec->codec_tag = 0;\n\n    } else {\n\n        codec->codec_tag = id;\n\n        codec->codec_id  = ff_wav_codec_get_id(id,\n\n                                               codec->bits_per_coded_sample);\n\n    }\n\n    if (size >= 18 && id != 0x0165) {  \/* We're obviously dealing with WAVEFORMATEX *\/\n\n        int cbSize = avio_rl16(pb); \/* cbSize *\/\n\n        if (big_endian) {\n\n            avpriv_report_missing_feature(codec, \"WAVEFORMATEX support for RIFX files\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        size  -= 18;\n\n        cbSize = FFMIN(size, cbSize);\n\n        if (cbSize >= 22 && id == 0xfffe) { \/* WAVEFORMATEXTENSIBLE *\/\n\n            parse_waveformatex(pb, codec);\n\n            cbSize -= 22;\n\n            size   -= 22;\n\n        }\n\n        if (cbSize > 0) {\n\n            av_freep(&codec->extradata);\n\n            if (ff_get_extradata(codec, pb, cbSize) < 0)\n\n                return AVERROR(ENOMEM);\n\n            size -= cbSize;\n\n        }\n\n\n\n        \/* It is possible for the chunk to contain garbage at the end *\/\n\n        if (size > 0)\n\n            avio_skip(pb, size);\n\n    } else if (id == 0x0165 && size >= 32) {\n\n        int nb_streams, i;\n\n\n\n        size -= 4;\n\n        av_freep(&codec->extradata);\n\n        if (ff_get_extradata(codec, pb, size) < 0)\n\n            return AVERROR(ENOMEM);\n\n        nb_streams         = AV_RL16(codec->extradata + 4);\n\n        codec->sample_rate = AV_RL32(codec->extradata + 12);\n\n        codec->channels    = 0;\n\n        bitrate            = 0;\n\n        if (size < 8 + nb_streams * 20)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < nb_streams; i++)\n\n            codec->channels += codec->extradata[8 + i * 20 + 17];\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        \/* Channels and sample_rate values are those prior to applying SBR\n\n         * and\/or PS. *\/\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    \/* override bits_per_coded_sample for G.726 *\/\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate \/ codec->sample_rate;\n\n\n\n    return 0;\n\n}\n"
    },
    {
        "project":"FFmpeg",
        "commit_id":"57d77b3963ce1023eaf5ada8cba58b9379405cc8",
        "target":0,
        "func":"int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t *src_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,\n\n                                      CL_TRUE,CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(mapped, src_buf, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n"
    },
    {
        "project":"FFmpeg",
        "commit_id":"aba232cfa9b193604ed98f3fa505378d006b1b3b",
        "target":1,
        "func":"static int r3d_read_rdvo(AVFormatContext *s, Atom *atom)\n\n{\n\n    R3DContext *r3d = s->priv_data;\n\n    AVStream *st = s->streams[0];\n\n    int i;\n\n\n\n    r3d->video_offsets_count = (atom->size - 8) \/ 4;\n\n    r3d->video_offsets = av_malloc(atom->size);\n\n    if (!r3d->video_offsets)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < r3d->video_offsets_count; i++) {\n\n        r3d->video_offsets[i] = avio_rb32(s->pb);\n\n        if (!r3d->video_offsets[i]) {\n\n            r3d->video_offsets_count = i;\n\n            break;\n\n        }\n\n        av_dlog(s, \"video offset %d: %#x\\n\", i, r3d->video_offsets[i]);\n\n    }\n\n\n\n    if (st->r_frame_rate.num)\n\n        st->duration = av_rescale_q(r3d->video_offsets_count,\n\n                                    (AVRational){st->r_frame_rate.den,\n\n                                                 st->r_frame_rate.num},\n\n                                    st->time_base);\n\n    av_dlog(s, \"duration %\"PRId64\"\\n\", st->duration);\n\n\n\n    return 0;\n\n}\n"
    },
    {
        "project":"FFmpeg",
        "commit_id":"afb4632cc30e83287338690c785ebac180436a59",
        "target":1,
        "func":"static int dds_decode(AVCodecContext *avctx, void *data,\n\n                      int *got_frame, AVPacket *avpkt)\n\n{\n\n    DDSContext *ctx = avctx->priv_data;\n\n    GetByteContext *gbc = &ctx->gbc;\n\n    AVFrame *frame = data;\n\n    int mipmap;\n\n    int ret;\n\n\n\n    ff_texturedsp_init(&ctx->texdsp);\n\n    bytestream2_init(gbc, avpkt->data, avpkt->size);\n\n\n\n    if (bytestream2_get_bytes_left(gbc) < 128) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Frame is too small (%d).\\n\",\n\n               bytestream2_get_bytes_left(gbc));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (bytestream2_get_le32(gbc) != MKTAG('D', 'D', 'S', ' ') ||\n\n        bytestream2_get_le32(gbc) != 124) { \/\/ header size\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid DDS header.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(gbc, 4); \/\/ flags\n\n\n\n    avctx->height = bytestream2_get_le32(gbc);\n\n    avctx->width  = bytestream2_get_le32(gbc);\n\n    ret = av_image_check_size(avctx->width, avctx->height, 0, avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid image size %dx%d.\\n\",\n\n               avctx->width, avctx->height);\n\n        return ret;\n\n    }\n\n\n\n    \/* Since codec is based on 4x4 blocks, size is aligned to 4. *\/\n\n    avctx->coded_width  = FFALIGN(avctx->width,  TEXTURE_BLOCK_W);\n\n    avctx->coded_height = FFALIGN(avctx->height, TEXTURE_BLOCK_H);\n\n\n\n    bytestream2_skip(gbc, 4); \/\/ pitch\n\n    bytestream2_skip(gbc, 4); \/\/ depth\n\n    mipmap = bytestream2_get_le32(gbc);\n\n    if (mipmap != 0)\n\n        av_log(avctx, AV_LOG_VERBOSE, \"Found %d mipmaps (ignored).\\n\", mipmap);\n\n\n\n    \/* Extract pixel format information, considering additional elements\n\n     * in reserved1 and reserved2. *\/\n\n    ret = parse_pixel_format(avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = ff_get_buffer(avctx, frame, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (ctx->compressed) {\n\n        int size = (avctx->coded_height \/ TEXTURE_BLOCK_H) *\n\n                   (avctx->coded_width \/ TEXTURE_BLOCK_W) * ctx->tex_ratio;\n\n        ctx->slice_count = av_clip(avctx->thread_count, 1,\n\n                                   avctx->coded_height \/ TEXTURE_BLOCK_H);\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < size) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Compressed Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        \/* Use the decompress function on the texture, one block per thread. *\/\n\n        ctx->tex_data = gbc->buffer;\n\n        avctx->execute2(avctx, decompress_texture_thread, frame, NULL, ctx->slice_count);\n\n    } else if (!ctx->paletted && ctx->bpp == 4 && avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n\n        uint8_t *dst = frame->data[0];\n\n        int x, y, i;\n\n\n\n        \/* Use the first 64 bytes as palette, then copy the rest. *\/\n\n        bytestream2_get_buffer(gbc, frame->data[1], 16 * 4);\n\n        for (i = 0; i < 16; i++) {\n\n            AV_WN32(frame->data[1] + i*4,\n\n                    (frame->data[1][2+i*4]<<0)+\n\n                    (frame->data[1][1+i*4]<<8)+\n\n                    (frame->data[1][0+i*4]<<16)+\n\n                    (frame->data[1][3+i*4]<<24)\n\n            );\n\n        }\n\n        frame->palette_has_changed = 1;\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < frame->height * frame->width \/ 2) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), frame->height * frame->width \/ 2);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        for (y = 0; y < frame->height; y++) {\n\n            for (x = 0; x < frame->width; x += 2) {\n\n                uint8_t val = bytestream2_get_byte(gbc);\n\n                dst[x    ] = val & 0xF;\n\n                dst[x + 1] = val >> 4;\n\n            }\n\n            dst += frame->linesize[0];\n\n        }\n\n    } else {\n\n        int linesize = av_image_get_linesize(avctx->pix_fmt, frame->width, 0);\n\n\n\n        if (ctx->paletted) {\n\n            int i;\n\n            \/* Use the first 1024 bytes as palette, then copy the rest. *\/\n\n            bytestream2_get_buffer(gbc, frame->data[1], 256 * 4);\n\n            for (i = 0; i < 256; i++)\n\n                AV_WN32(frame->data[1] + i*4,\n\n                        (frame->data[1][2+i*4]<<0)+\n\n                        (frame->data[1][1+i*4]<<8)+\n\n                        (frame->data[1][0+i*4]<<16)+\n\n                        (frame->data[1][3+i*4]<<24)\n\n                );\n\n\n\n            frame->palette_has_changed = 1;\n\n        }\n\n\n\n        if (bytestream2_get_bytes_left(gbc) < frame->height * linesize) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Buffer is too small (%d < %d).\\n\",\n\n                   bytestream2_get_bytes_left(gbc), frame->height * linesize);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        av_image_copy_plane(frame->data[0], frame->linesize[0],\n\n                            gbc->buffer, linesize,\n\n                            linesize, frame->height);\n\n    }\n\n\n\n    \/* Run any post processing here if needed. *\/\n\n    if (ctx->postproc != DDS_NONE)\n\n        run_postproc(avctx, frame);\n\n\n\n    \/* Frame is ready to be output. *\/\n\n    frame->pict_type = AV_PICTURE_TYPE_I;\n\n    frame->key_frame = 1;\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n"
    },
    {
        "project":"FFmpeg",
        "commit_id":"da032427786d9db4ab21014998cb1245083d6c85",
        "target":1,
        "func":"static void check_lowpass_line(int depth){\n\n    LOCAL_ALIGNED_32(uint8_t, src,     [SRC_SIZE]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst_ref, [WIDTH_PADDED]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst_new, [WIDTH_PADDED]);\n\n    int w = WIDTH;\n\n    int mref = WIDTH_PADDED * -1;\n\n    int pref = WIDTH_PADDED;\n\n    int i, depth_byte;\n\n    InterlaceContext s;\n\n\n\n    declare_func(void, uint8_t *dstp, ptrdiff_t linesize, const uint8_t *srcp,\n\n                 ptrdiff_t mref, ptrdiff_t pref, int clip_max);\n\n\n\n    s.lowpass = 1;\n\n    s.lowpass = VLPF_LIN;\n\n    depth_byte = depth >> 3;\n\n    w \/= depth_byte;\n\n\n\n    memset(src,     0, SRC_SIZE);\n\n    memset(dst_ref, 0, WIDTH_PADDED);\n\n    memset(dst_new, 0, WIDTH_PADDED);\n\n    randomize_buffers(src, SRC_SIZE);\n\n\n\n    ff_interlace_init(&s, depth);\n\n\n\n    if (check_func(s.lowpass_line, \"lowpass_line_%d\", depth)) {\n\n        for (i = 0; i < 32; i++) { \/* simulate crop *\/\n\n            call_ref(dst_ref, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n\n            call_new(dst_new, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n\n            if (memcmp(dst_ref, dst_new, WIDTH - i))\n\n                fail();\n\n        }\n\n        bench_new(dst_new, w, src + WIDTH_PADDED, mref, pref, 0);\n\n    }\n\n}\n"
    },
    {
        "project":"qemu",
        "commit_id":"aa1530dec499f7525d2ccaa0e3a876dc8089ed1e",
        "target":1,
        "func":"static void filter_mirror_setup(NetFilterState *nf, Error **errp)\n{\n    MirrorState *s = FILTER_MIRROR(nf);\n    Chardev *chr;\n    chr = qemu_chr_find(s->outdev);\n    if (chr == NULL) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", s->outdev);\n    qemu_chr_fe_init(&s->chr_out, chr, errp);"
    },
    {
        "project":"qemu",
        "commit_id":"b4ba67d9a702507793c2724e56f98e9b0f7be02b",
        "target":1,
        "func":"static void test_init(TestData *d)\n\n{\n\n    QPCIBus *bus;\n\n    QTestState *qs;\n\n    char *s;\n\n\n\n    s = g_strdup_printf(\"-machine q35 %s %s\",\n\n                        d->noreboot ? \"\" : \"-global ICH9-LPC.noreboot=false\",\n\n                        !d->args ? \"\" : d->args);\n\n    qs = qtest_start(s);\n\n    qtest_irq_intercept_in(qs, \"ioapic\");\n\n    g_free(s);\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    d->dev = qpci_device_find(bus, QPCI_DEVFN(0x1f, 0x00));\n\n    g_assert(d->dev != NULL);\n\n\n\n    qpci_device_enable(d->dev);\n\n\n\n    \/* set ACPI PM I\/O space base address *\/\n\n    qpci_config_writel(d->dev, ICH9_LPC_PMBASE, PM_IO_BASE_ADDR | 0x1);\n\n    \/* enable ACPI I\/O *\/\n\n    qpci_config_writeb(d->dev, ICH9_LPC_ACPI_CTRL, 0x80);\n\n    \/* set Root Complex BAR *\/\n\n    qpci_config_writel(d->dev, ICH9_LPC_RCBA, RCBA_BASE_ADDR | 0x1);\n\n\n\n    d->tco_io_base = qpci_legacy_iomap(d->dev, PM_IO_BASE_ADDR + 0x60);\n\n}\n"
    }
]